criValue = AIC(fit)
} else if (criterion == "BIC") {
criValue = BIC(fit)
} else {
criValue = criFun(fit)
}
result[1,i] = criValue
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
eval(parse(text="AIC"))()
?vector
test = vector(popSize)
vector(5)
vector(any, 5)
rep(NA, popSize)
eval(parse(text = criterion))
eval(parse(text = "criterion"))
?is.function
is.function(AIC)
!is.function(AIC)
?try
?foreach
singleEval <- function(singleGene, X, y, criterion, criFun){
fit <- lm(y~as.matrix(X[,which(genePool[i,] != 0, arr.ind = T)]))
if(!is.na(criFun)){    # Dont have their own criterion function written
criFun <- eval(parse(text = criterion))
criValue <- criFun(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
if(criterion!="AIC" | criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.function(criFun))
stop(paste(criFun, "is not a function."))
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
for (i in 1:popSize){
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
result[i] <- criValue
}
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
genePool
dim(X)
dim(genePool)
X <- mtcars[,2:11]
y <- mtcars[,1]
X <- mtcars[,2:11]
dim(X)
genePool <- popInitialize(20, geneLength = 10, zeroToOneRatio = 2 )
popSize
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
criterion
criterion!="AIC" | criterion!= "BIC"
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.function(criFun))
stop(paste(criFun, "is not a function."))
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
for (i in 1:popSize){
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
result[i] <- criValue
}
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
!is.na(criFun) & !is.function(criFun)
criFun =NA
!is.na(criFun) & !is.function(criFun)
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.na(criFun) & !is.function(criFun))
stop(paste(criFun, "is not a function."))
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
for (i in 1:popSize){
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
result[i] <- criValue
}
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
is.function(NA)
!is.na(criFun)
singleEval <- function(singleGene, X, y, criterion, criFun){
fit <- lm(y~as.matrix(X[,which(genePool[i,] != 0, arr.ind = T)]))
if(!is.na(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.na(criFun) & !is.function(criFun))
stop(paste(criFun, "is not a function."))
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
for (i in 1:popSize){
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
result[i] <- criValue
}
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
criFun
!is.na(criFun) & !is.function(criFun)
!is.function(criFun)
singleEval <- function(singleGene, X, y, criterion, criFun){
fit <- lm(y~as.matrix(X[,which(genePool[i,] != 0, arr.ind = T)]))
if(!is.na(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.na(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
#   for (i in 1:popSize){
#     criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
#     result[i] <- criValue
#   }
#
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
popSize = 20
criterion
criFun
criterion!="AIC" & criterion!= "BIC"
!is.na(criFun) & !is.function(criFun)
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
geneLength
result
criValue <- singleEval(genePool[1,], X, y, criterion, criFun)
fit <- lm(y~as.matrix(X[,which(genePool[i,] != 0, arr.ind = T)]))
!is.na(criFun)
singleEval <- function(singleGene, X, y, criterion, criFun){
fit <- lm(y~as.matrix(X[,which(genePool[i,] != 0, arr.ind = T)]))
if(is.na(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.na(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
#    for (i in 1:popSize){
#      criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
#      result[i] <- criValue
#    }
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
genePool
singleEval(genePool[1,], X, y, criterion, criFun)
singleEval(genePool[2,], X, y, criterion, criFun)
singleEval(genePool[3,], X, y, criterion, criFun)
genePool[3,]
genePool[4,]
singleEval(genePool[4,], X, y, criterion, criFun)
singleGene
?which
singleEval <- function(singleGene, X, y, criterion, criFun){
fit <- lm(y~as.matrix(X[,which(singleGene != 0)]))
if(is.na(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
i
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
evalLm <- function(genePool, X, y, popSize, criterion = "AIC", criFun = NA){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.na(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
geneLength <- dim(genePool)[2]
result <- rep(NA, popSize)
#    for (i in 1:popSize){
#      criValue <-
singleEval(genePool[3,], X, y, criterion, criFun)
#      result[i] <- criValue
#    }
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(genePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
jflkdsajl;kf)
rank(c(-1,0,1))
evalLm(genePool, X, y, popSize = 20, criterion = "AIC", criFun = NA)
evalLm(genePool, X, y, popSize = 5, criterion = "AIC", criFun = NA)
singleEval <- function(singleGene, X, y, criterion, criFun){
if(type = "lm")
fit <- lm(y~as.matrix(X[,which(singleGene != 0)]))
else if(type = "glm")
fit <- glm(as.vector(y)~as.matrix(X[,which(singleGene != 0)]), family)
else
stop("Not a valid type. Must be 'lm' or 'glm'")
if(is.na(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
?if
hjghjkg)
type ="lm"
type != "lm" | type != "glm"
type != "lm" & type != "glm"
is.na(NULL)
is.null(criFun)
singleEval <- function(singleGene, X, y, criterion, criFun){
if(type = "lm")
fit <- lm(y~as.matrix(X[,which(singleGene != 0)]))
if(type = "glm")
fit <- glm(as.vector(y)~as.matrix(X[,which(singleGene != 0)]), family)
if(is.null(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
singleEval <- function(singleGene, X, y, criterion, criFun){
if(type == "lm")
fit <- lm(y~as.matrix(X[,which(singleGene != 0)]))
if(type == "glm")
fit <- glm(as.vector(y)~as.matrix(X[,which(singleGene != 0)]), family)
if(is.null(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
evalFunction <- function(currentGenePool, X, y, popSize, type, criterion = "AIC", criFun = NULL){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.na(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalFunction(genePool, X, y, popSize = 5, type = "lm", criterion = "AIC", criFun = NULL)
evalFunction <- function(currentGenePool, X, y, popSize, type, criterion = "AIC", criFun = NULL){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.null(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalFunction(genePool, X, y, popSize = 5, type = "lm", criterion = "AIC", criFun = NULL)
evalFunction2 <- function(currentGenePool, X, y, popSize, type, family = "gaussian", criterion = "AIC", criFun = NULL){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.null(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
tmp <- evalFunction(currentGenePool, "lm", "AIC")
evalFunction2 <- function(currentGenePool, X, y, popSize, type = "lm", family = "gaussian", criterion = "AIC", criFun = NULL){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.null(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalFunction2(genePool, X, y, popSize = 5, type = "lm", criterion = "AIC", criFun = NULL)
tmp <- evalFunction2(currentGenePool, "lm", "AIC")
popSize
tmp <- evalFunction2(currentGenePool, popsize, type = "lm", criterion = "AIC")
tmp <- evalFunction2(currentGenePool, popSize, type = "lm", criterion = "AIC")
tmp <- evalFunction2(currentGenePool, popSize = 5, type = "lm", criterion = "AIC")
evalFunction2 <- function(currentGenePool, X, y, type = "lm", family = "gaussian", criterion = "AIC", criFun = NULL){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.null(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
popSize
tmp <- evalFunction2(currentGenePool, type = "lm", criterion = "AIC")
evalFunction2 <- function(currentGenePool, type = "lm", family = "gaussian", criterion = "AIC", criFun = NULL){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.null(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalFunction2(genePool, type = "lm", criterion = "AIC", criFun = NULL)
tmp <- evalFunction2(currentGenePool, type = "lm", criterion = "AIC")
tmp
evalFunction2 <- function(currentGenePool, type = "lm", family = "gaussian", criterion = "AIC", criFun = NULL){
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.null(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, criterion, criFun)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalFunction2(genePool, type = "lm", criterion = "AIC", criFun = NULL)
evalFunction2(genePool, type = "lm", criterion = "AIC", criFun = NULL)
X <- mtcars[,2:11]
y <- mtcars[,1]
select_test <- function(X = NULL, y = NULL, popSize = 200, criterion = "AIC", type = "lm", family = NA, criFun = NULL, max_iterations = 500, min_iterations = 50, crossRate = NA, mRate = NA, zeroToOneRatio = 2){
##### Defense coding #####
X <- as.matrix(X)
y <- as.vector(y)
if(is.na(mRate)){
mRate = 1/(dim(X)[1]);
}
if(is.null(evalFunction2)){
stop("Please provide an evaluation function! Exiting from the function")
}
if(is.null(X)){
stop("Please provide the predictors! Exiting from the function")
}
if(is.null(y)){
stop("Please provide the independent variable/outcome! Exiting from the function")
}
##### Beginning of the generic algorithm #####
geneLength <- dim(X)[2]
##### Initializing the first generation of individuals/ models
initialPopulation <- popInitialize(popSize, geneLength, zeroToOneRatio)
currentGenePool <- initialPopulation
### Calculating the sampling probabilities for the first generations of individuals/models
#samplingProb <- evalFunction2(currenGenePool, type, criterion, family, criFun)[3,]
samplingProb <- evalFunction2(currentGenePool, type, family, criterion, criFun)[3,]
### While loop to handle convergence/ exceedance of min iteration/ capped by max iteration
#iter = 0;
### Condition to be satisfied
### if iter < min_iteration
#while((iter <= min_iterations)&& !(iter >= max_iterations))
for(i in 1:max_iterations){
# really we will have predetermined # of iterations
#xSamp <- updateSamp(x, popSize, weights)
geneSample <- updateSamp(currentGenePool, popSize, samplingProb)
#xCrossed = matrix(NA, nrow = popSize, ncol = geneLength)
crossedSample <- matrix(NA, nrow = popSize, ncol = geneLength)
#for(i in seq(1, popSize, by = 2))
#  xCrossed[i:(i+1),] <- crossover(xSamp[i,], xSamp[i+1,], popSize, geneLength, crossRate)
for(i in seq(1, popSize, by = 2)){
print(i)
crossedSample[i:(i+1),] <- crossover(geneSample[i,], geneSample[i+1, ], geneLength, crossRate)
}
#
#xMut = matrix(NA, nrow = popSize, ncol = geneLength)
mutatedSample <- matrix(NA, nrow = popSize, ncol = geneLength)
#for(i in seq(1, popSize, by = 2))
#  xMut[i:(i+1),] <- mutation(xCrossed[i,], xCrossed[i+1,], mRate)
for (i in seq(1, popSize, by = 2)){
#mutatedSample <- mutation(crossedSample[i,], crossedSample[i+1,], popSize, mRate)
mutatedSample[i:(i+1),] <- mutation(crossedSample[i,], crossedSample[i+1,], mRate)
}
### Here we would add the evaluation function ###
# weights = AIC(  )
currentGenePool <- mutatedSample
samplingProb <- evalFunction2(currentGenePool, type, family, criterion, criFun)[3,]
#x = xMut # Update x-matrix with our new one!
print(x) # take out later
}
##### After a fixed number of iterations, we return the best model #####
return(currentGenePool)
##### Print the best model #####
}
system.time({result <- select_test(X, y, popSize = 200, max_iterations = 100, crossRate = 0.95, mRate = 0.001)
result})
