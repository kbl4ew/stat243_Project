### While loop to handle convergence/ exceedance of min iteration/ capped by max iteration
#iter = 0;
### Condition to be satisfied
### if iter < min_iteration
#while((iter <= min_iterations)&& !(iter >= max_iterations))
for(i in 1:max_iterations){
geneSample <- updateSamp(currentGenePool, popSize, samplingProb)
crossedSample <- crossedParallel(geneSample, geneLength, crossRate, popSize)
mutatedSample <- mutationParallel(crossedSample, mRate, popSize)
currentGenePool <- mutatedSample
samplingProb <- evalFunction2(currentGenePool, popSize, type, family, criterion, criFun)[3,]
}
##### After a fixed number of iterations, we return the best model #####
return(currentGenePool)
##### Print the best model #####
}
system.time({result_test <- select_test2(X, y, popSize = 10, max_iterations = 30, type = "lm",
crossRate = 0.95, mRate = 0.001)
result})
mtcars
m1 = lm(mpg~cyl + disp, data = mtcars)
summary(m1)
adj.r.squared(m1)
m1$adj.r.squared
m1$adj.r.squared
m1
m1$r.squared
summary(m1)$r.squared
summary(m1)$adj.r.squared
print(try(log("a"), TRUE))
try(log("a"), TRUE)
a = try(log("a"), TRUE)
print(a)
print(a)[1]
summary(a)
b = try(log(1), TRUE)
summary(b)
summary(a)
attributes(a)
a$class
attributes(a)$class
attributes(b)$class
c = try(lm(0~1))
c
attributes(c)
c = try(lm(x~y))
c = try(5/0)
c
c = try(c(1,2)+c(1,2,3))
?try
c = try(c(1,2)+c(1,2,3), silent = TRUE)
c = suppressWarnings(try(c(1,2)+c(1,2,3), silent = TRUE))
c
c = try(sqrt(-1)), silent = TRUE)
c = try(sqrt(-1), silent = TRUE)
c
c, silent = TRUE)
summary(c)
y = c(0,1,0,1,0)
unique(y)
length(unique(y))
y = c(0,1,0,1,0, NA)
length(unique(y))
length(unique(na.rm(y)))
?na.rm
na.omit
?na.omit
length(unique(na.omit(y)))
m1
m1*2
c = try(m1*2)
c = try(m1*2, )
?try
c = try(m1*2, silent = TRUE)
c
attributes(c)
attributes(c)$class
a = function()
return(4)
a
is.character(a)
is.character(a)
is.character(NA)
!is.null(a) & !is.function(a)
a
!is.null("a") & !is.function("a")
a(5)
attributes(c)$class
attributes(c)
attributes(c)$condition
c
summary(c)
str(c)
str(c)$message
c$message
names(c)
attributes(message)
attributes(c)
c
try
c$prefix
c$condition
attribute(c)$condition
attributes(c)$condition
a
b
d = try(log(-1))
d
d = try(log("a"))
d = try(log("a"), silent = TRUE)
d
geterrmessage
geterrmessage()
cat(geterrmessage())
attributes(c)$class
attributes(c)$class == "try-error"
b
attributes(b)$class
attributes(b)$class == "try-error"
if(attributes(b)$class == "try-error") print("a")
!is.nullattributes(b)$class
!is.null(attributes(b)$class)
!is.null(attributes(b)$class) & attributes(b)$class == "try-error"
if(!is.null(attributes(b)$class) & attributes(b)$class == "try-error") print("a")
!is.null(attributes(b)$class
)
!is.null(attributes(c)$class)
attributes(c)$class == "try-error"
cat(geterrmessage())
cat(geterrmessage())
log("a")
cat(geterrmessage())
cat(paste("The criFun is not compatible with", geterrmessage()))
cat(paste("The criFun is not compatible with\n", geterrmessage()))
cat(paste("The criFun is not compatible with", type, "\n", geterrmessage()))
type = "lm"
cat(paste("The criFun is not compatible with", type, "\n", geterrmessage()))
cat(paste("The criFun is not compatible with", type, "The following error occured:\n", geterrmessage()))
cat(paste("The criFun is not compatible with", type, "\nThe following error occured:\n", geterrmessage()))
cat(paste("The criFun is not compatible. The following error occured:\n", geterrmessage()))
length(a)
is.numeric(1)
!is.numeric(1)
!is.numeric("a")
singleEval <- function(singleGene, X, y, type, criterion, criFun){
if(type == "lm")
fit <- lm(y~as.matrix(X[,which(singleGene != 0)]))
if(type == "glm")
fit <- glm(as.vector(y)~as.matrix(X[,which(singleGene != 0)]), family)
if(is.null(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = try(criFun(fit), silent = TRUE)   # use the function inputted by the user; CHECK FOR ERRORS?
if(!is.null(attributes(criValue)$class))
if(attributes(criValue)$class == "try-error")
stop(cat(paste("criFun is not compatible. The following error occured:\n", geterrmessage())))
if(length(criValue)!=1)
stop("Dimension of output for criFun greater than 1.")
if(!is.numeric(criValue)!=1)
stop("Output for criFun is not numeric.")
return(criValue)
}
cri = "AIC"
eval(parse(text = cri))
AIC
eval(parse(text = "BIC"))
m1
criFunBuilt <- eval(parse(text = "AIC"))
criFunBuilt(m1)
criFunBuilt <- eval(parse(text = "BIC"))
a
b = function(fun){ return(a)}
b
b()
summary(m1)
b = function(fun){ return(fun)}
b(a)
b = function(fun){ return(fun(1))}
b
b(a)
a
a(1)
cp(m1)
?cp
?Cp
m1$adj.r.squared
summary(m1)$adj.r.squared
fun <- function(lm_ob){
ad_r_squared <- summary(lm_ob)$adj.r.squared
return( - ad_r_squared)
}
fun(m1)
fun <- function(lm_ob){
ad_r_squared <- summary(lm_ob)$adj.r.squared
return( - ad_r_squared)
}
qog <- read.csv("~/src/qog.csv")
head(qog)
qog <- read.csv("~/src/qog.csv", sep = ";")
head(qog)
names(qog)
sort(names(qog))
qog_set <- with(qog, cname == "Argentina")
dim(qog_set)
table(qog$cname)
sort(qog$cname
)
sort(unique(qog$cname))
qog <- read.csv("~/src/qog.csv", sep = ";", stringsAsFactors = FALSE)
sort(unique(qog$cname))
qog_set <- qog[with(qog, cname == "Argentina")]
qog_set <- qog[with(qog, cname == "Argentina"),]
dim(qog_set)
qog_set <- qog[with(qog, cname == "Argentina" | cname =="Brazil", cname =="Brazil" |
cname == "El Salvador" | cname == "United States" | cname == "China" |
cname == "Thailand" | cname == "Tanzania" | cname == "Botswana" | cname == "Chad"),]
dim(qog_set)
sort(unique(qog_set$cname))
qog_set <- qog[with(qog, cname == "Argentina" | cname =="Brazil" | cname == "El Salvador" |
cname == "United States" | cname == "China" | cname == "Thailand" |
cname == "Tanzania" | cname == "Botswana" | cname == "Chad"),]
sort(unique(qog_set$cname))
m1 <- lm(wdi_gdpgr ~ pwt_isg + cname + year, data = qog_set)
summary(m1)
m1 <- lm(wdi_gdpgr ~ pwt_isg + cname, data = qog_set)
summary(m1)
names(wdi_fdi)
sort(names(qog_set))
qog <- read.csv("~/src/QoG2013_selectedvars.csv", stringsAsFactors = FALSE)
head(qog)
qog_set <- qog[with(qog, cname == "Argentina" | cname =="Brazil" | cname == "El Salvador" |
cname == "United States" | cname == "China" | cname == "Thailand" |
cname == "Tanzania" | cname == "Botswana" | cname == "Chad"),]
summary(qog)
qog_set <- qog[with(qog, cname == "Argentina" | cname =="Brazil" | cname == "El Salvador" |
cname == "United States" | cname == "China" | cname == "Thailand" |
cname == "Tanzania" | cname == "Botswana" | cname == "Chad"),]
names(qog)
View(names(qog))
qog_set <- qog[with(qog, Country.Name == "Argentina" | Country.Name =="Brazil" | Country.Name == "El Salvador" |
Country.Name == "United States" | Country.Name == "China" | Country.Name == "Thailand" |
Country.Name == "Tanzania" | Country.Name == "Botswana" | Country.Name == "Chad"),]
View(sort(names(qog)))
head(qot$Foreign.Direct.Investments..Net.Inflows....of.GDP.)
head(qog_set$Foreign.Direct.Investments..Net.Inflows....of.GDP.)
summary(qog_set$Foreign.Direct.Investments..Net.Inflows....of.GDP.)
dim(qog_set)
names(qog_set$Foreign.Direct.Investments..Net.Inflows....of.GDP.)
summary(qog_set$GDP.per.Capita.Growth....)
m1 <- lm(GDP.per.Capita.Growth.... ~ Foreign.Direct.Investments..Net.Inflows....of.GDP. +
Country.Name + Year, data = qog_set)
summary(m1)
library('knitr')
setwd('~/src/stat243_Project')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
registerDoParallel(nCores)
try(registerDoParallel(nCores))
try(registerDoParallel(nCores), silent = TRUE)
check = try(registerDoParallel(nCores), silent = TRUE)
check
attributes(check)[2]
attributes(check)[1]
attributes(check)[1] == "try-error"
cat("Please load the following packages before implementing:\n1) parallel\n2) doParallel\n3) foreach\n4) iterators")
library(parallel)
library(doParallel)
library(foreach)
library(iterators)
nCores <- 4
checkLoaded = try(registerDoParallel(nCores), silent = TRUE)
checkLoaded
singleEval <- function(singleGene, X, y, type, criterion, criFun, family){
if(type == "lm")
fit <- lm(y~as.matrix(X[,which(singleGene != 0)]))
if(type == "glm")
fit <- glm(as.vector(y)~as.matrix(X[,which(singleGene != 0)]), family)
if(is.null(criFun)){    # Dont have their own criterion function written
criFunBuilt <- eval(parse(text = criterion))
criValue <- criFunBuilt(fit)
}
else
criValue = criFun(fit)   # use the function inputted by the user; CHECK FOR ERRORS?
return(criValue)
}
evalFunction <- function(currentGenePool, popSize, type = "lm", family = "gaussian", criterion = "AIC", criFun = NULL){
if((popSize %% 2)!= 0){
message("Warning: The size of the population has been rounded to the largest even numer")
popSize <- popSize + 1;
}
if(criterion!="AIC" & criterion!= "BIC")  ### ADD MORE?
stop(paste(criterion, "is not a valid criterion. Please use AIC or BIC."))
if(!is.null(criFun) & !is.function(criFun))
stop("criFun input is not a function.")
if(type != "lm" & type != "glm")
stop("Regression must be of type 'lm' or 'glm'")
geneLength <- dim(currentGenePool)[2]
result <- rep(NA, popSize)
result <- foreach(i = 1:popSize, .combine = c)  %dopar% {
criValue <- singleEval(currentGenePool[i,], X, y, type, criterion, criFun, family)
return(criValue)
}
obj <- rbind(result, rank(result), rank(-result)/sum(1:popSize))
row.names(obj) <- c(criterion, "ranks", "samplingProbs")
return(obj)
}
evalFunction2(genePool, popSize = 4, type = "lm", criterion = "AIC", criFun = NULL)
popInitialize <- function(popSize = 0, geneLength = 0, zeroToOneRatio){
if(is.na(zeroToOneRatio)){
zeroToOneRation = 0;
}
else{
#
}
pop <- matrix(nrow = popSize, ncol = geneLength);
##### Randomly initialize the first generation #####
for (child in 1:popSize){
pop[child, ] = sample(c(rep(0, zeroToOneRatio), 1), geneLength, replace = TRUE);
while(sum(pop[child,]) == 0){
pop[child, ] = sample(c(rep(0, zeroToOneRatio), 1), geneLength, replace = TRUE);
}
}
return(pop)
}
genePool = popInitialize(10, )fjkdlas
X <- mtcars[,2:11]
y <- mtcars[,1]
genePool = popInitialize(10, dim(X[2], 2)
)
genePool = popInitialize(10, dim(X)[2], 2)
genePool
evalFunction(genePool, popSize = 10, type = "lm", criterion = "AIC", criFun = NULL)
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
?foreach
?foreach
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
y = mtcars[,1]
X = mtcars[,2:11]
y
x
X
class(X)
lm(y~X)
X
names(X)
lm(y~names(X))
length(names)
length(names(X))
names(X)
names(X)[1]
paste(names(X)[1] "+" names(X)[2])
paste(names(X)[1], "+", names(X)[2])
test = paste(names(X)[1], "+", names(X)[2])
eval(parse(text = test))
parse(text = test)
lm(y, eval(parse(text = test)), data = cbind(y, X))
lm(y~eval(parse(text = test)), data = cbind(y, X))
summary(lm(y~eval(parse(text = test)), data = cbind(y, X)))
test
test = matrix(rep(1, 10), nrows = 5)
test = matrix(rep(1, 10), nrow = 5)
names(test)
dat = cbind(y, X)
head(dat)
eval(parse(text = "AIC"))
?parse
eval(parse(text = test))
test
test = paste(names(X)[1], "+", names(X)[2])
test
substitute(test)
lm(formula = substitute(read ~ i, list(i = as.name(x))), data = hsb2)
lm(substitute(y ~ i, list(i = as.name(X))))
lm(substitute(y ~ list(i = as.name(X))))
lm(substitute(y ~ test))
test
X
names(X)
as.name(X)
paste(names(X), sep ="+")
as.formula(paste("y~test"))
test
as.formula(paste("y~", test))
formula = as.formula(paste("y~", test))
lm(formula)
lm(formula, data = cbind(y, X))
summary(lm(formula, data = cbind(y, X)))
X
X[c(1,2,3)]
names(X[c(1,2,3)])
print(names(X[c(1,2,3)]), sep = "+")
paste(names(X[c(1,2,3)]), sep = "+")
paste(names(X[c(1,2,3)]), sep = "+")
names(X)
paste(names(X), sep = "+")
cat(paste(names(X), sep = "+"))
cat((names(X), sep = "+"))
class(names(X))
cat(paste(as.list(names(X)), sep = "+"))
paste(as.list(names(X)), sep = "+")
for(i in 1:length(X)){}
cat(names(X), sep = "+")
print(names(X), sep = "+")
cat(names(X), sep = "+")
string = cat(names(X), sep = "+")
string
paste(names(X), collapse = "+")
formula <- paste(y, paste(names(X), collapse = "+"))
formula
paste(names(X), collapse = "+")
formula <- paste("y", paste(names(X), collapse = "+"))
formula
formula <- paste("y~", paste(names(X), collapse = "+ "))
formula
formula <- paste("y~", paste(names(X), collapse = " + "))
forumla
formula
formula <- as.formula(paste("y ~", paste(names(X), collapse = " + ")))
formula
y
X
lm(formula, data = cbind(y, X))
paste("v", 1:dim(X)[2], sep = "")
names(X) <- paste("v", 1:dim(X)[2], sep = "")
names(X)
X
test = matrix(rep(10, nrow = 2))
test
test = matrix(rep(1, 10), nrow = 2))
test
test = matrix(rep(1, 10), nrow = 2)
names(test)
dim(test)[2]
names(test) <- paste("v", 1:dim(test)[2], sep = "")
test
names(test)
col.names(test)
colnames(test)
colnames(X)
colnames(test) <-  paste("v", 1:dim(test)[2], sep = "")
test
test = matrix(rep(1, 10), nrow = 2)
colnames(test) <-  paste("v", 1:dim(test)[2], sep = "")
test
X = mtcars[,2:11]
y = mtcars[,1]
colnames(X) <- paste("v", 1:dim(X)[2], sep = "")
formula <- as.formula(paste("y ~", paste(names(X), collapse = " + ")))
model = lm(formula, data = cbind(y, X))
summary(model)
test
as.data.frame(test)
test = matrix(seq(1:12), nrow = 3)
test
as.data.frame(test)
test2 = list(c(1:3), c(1:3))
test2
as.data.frame(test2)
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
paste("+", NULL)
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
knit2pdf('Project_copy.Rtex')
as.character(as.formula("y~x"))
print(as.formula("y~x"))
